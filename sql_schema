-- WARNING: This schema is for context only and is not meant to be run.
-- Table order and constraints may not be valid for execution.

CREATE TABLE public.booking_sources (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL UNIQUE,
  description text,
  created_at timestamp with time zone DEFAULT now(),
  color text,
  CONSTRAINT booking_sources_pkey PRIMARY KEY (id)
);
CREATE TABLE public.bookings (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  check_in date,
  check_out date,
  status USER-DEFINED DEFAULT 'pending'::booking_status,
  total_amount numeric,
  created_at timestamp with time zone DEFAULT now(),
  source_id uuid,
  CONSTRAINT bookings_pkey PRIMARY KEY (id),
  CONSTRAINT bookings_source_id_fkey FOREIGN KEY (source_id) REFERENCES public.booking_sources(id)
);
CREATE TABLE public.expenses (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  booking_id uuid,
  name text,
  amount numeric,
  date date,
  month integer,
  year integer,
  created_at timestamp with time zone DEFAULT now(),
  is_variable boolean NOT NULL DEFAULT false,
  CONSTRAINT expenses_pkey PRIMARY KEY (id),
  CONSTRAINT expenses_booking_id_fkey FOREIGN KEY (booking_id) REFERENCES public.bookings(id)
);
CREATE TABLE public.housekeeping_staff (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text,
  contact text,
  email text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT housekeeping_staff_pkey PRIMARY KEY (id)
);
CREATE TABLE public.housekeeping_tasks (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  room_number text,
  task_type text,
  assigned_staff uuid NOT NULL,
  due_date date,
  due_time time without time zone,
  priority text,
  priority_weight integer DEFAULT 3 CHECK (priority_weight >= 1 AND priority_weight <= 5),
  status USER-DEFINED DEFAULT 'pending'::housekeeping_task_status,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT housekeeping_tasks_pkey PRIMARY KEY (id),
  CONSTRAINT housekeeping_tasks_assigned_staff_fkey FOREIGN KEY (assigned_staff) REFERENCES public.housekeeping_staff(id)
);
CREATE TABLE public.inventory_categories (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT inventory_categories_pkey PRIMARY KEY (id)
);
CREATE TABLE public.inventory_items (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  category_id uuid NOT NULL,
  name text,
  unit text,
  current_stock integer,
  min_stock integer,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT inventory_items_pkey PRIMARY KEY (id),
  CONSTRAINT inventory_items_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.inventory_categories(id)
);
CREATE TABLE public.notifications (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  type text,
  title text,
  message text,
  priority USER-DEFINED DEFAULT 'medium'::notification_priority,
  is_read boolean DEFAULT false,
  related_booking uuid,
  related_task uuid,
  related_item uuid,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT notifications_pkey PRIMARY KEY (id),
  CONSTRAINT notifications_related_booking_fkey FOREIGN KEY (related_booking) REFERENCES public.bookings(id),
  CONSTRAINT notifications_related_task_fkey FOREIGN KEY (related_task) REFERENCES public.housekeeping_tasks(id),
  CONSTRAINT notifications_related_item_fkey FOREIGN KEY (related_item) REFERENCES public.inventory_items(id)
);
CREATE TABLE public.revenue (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  booking_id uuid,
  expense_id uuid,
  income numeric DEFAULT 0.00,
  expense numeric DEFAULT 0.00,
  net_income numeric DEFAULT (COALESCE(income, (0)::numeric) - COALESCE(expense, (0)::numeric)),
  month integer,
  year integer,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT revenue_pkey PRIMARY KEY (id),
  CONSTRAINT revenue_booking_id_fkey FOREIGN KEY (booking_id) REFERENCES public.bookings(id),
  CONSTRAINT revenue_expense_id_fkey FOREIGN KEY (expense_id) REFERENCES public.expenses(id)
);

-- ==========================================================
-- 1️⃣  ENUM types (used by column defaults and RLS)
-- ==========================================================
CREATE TYPE IF NOT EXISTS booking_status           AS ENUM ('pending','confirmed','cancelled','completed');
CREATE TYPE IF NOT EXISTS housekeeping_task_status AS ENUM ('pending','in-progress','done');
CREATE TYPE IF NOT EXISTS notification_priority    AS ENUM ('low','medium','high');

/* -------------------------------------------------
   3️⃣  Indexes (including the one you added)
   ------------------------------------------------- */
-- FK‑related indexes
CREATE INDEX IF NOT EXISTS idx_expenses_booking_id
    ON public.expenses (booking_id);
CREATE INDEX IF NOT EXISTS idx_inventory_items_category_id
    ON public.inventory_items (category_id);
CREATE INDEX IF NOT EXISTS idx_housekeeping_tasks_assigned_staff
    ON public.housekeeping_tasks (assigned_staff);
CREATE INDEX IF NOT EXISTS idx_housekeeping_tasks_priority_weight
    ON public.housekeeping_tasks (priority_weight);
CREATE INDEX IF NOT EXISTS idx_notifications_booking
    ON public.notifications (related_booking);
CREATE INDEX IF NOT EXISTS idx_notifications_task
    ON public.notifications (related_task);
CREATE INDEX IF NOT EXISTS idx_notifications_item
    ON public.notifications (related_item);

-- Date / analytics indexes
CREATE INDEX IF NOT EXISTS idx_bookings_created_at
    ON public.bookings (created_at);
CREATE INDEX IF NOT EXISTS idx_expenses_created_at
    ON public.expenses (created_at);
CREATE INDEX IF NOT EXISTS idx_revenue_created_at
    ON public.revenue (created_at);
CREATE INDEX IF NOT EXISTS idx_expenses_month_year
    ON public.expenses (month, year);
CREATE INDEX IF NOT EXISTS idx_revenue_month_year
    ON public.revenue (month, year);
CREATE INDEX IF NOT EXISTS idx_notifications_created_at
    ON public.notifications (created_at);
CREATE INDEX IF NOT EXISTS idx_notifications_is_read
    ON public.notifications (is_read);

-- Index you specifically requested
CREATE INDEX IF NOT EXISTS idx_bookings_check_in
    ON public.bookings (check_in);


/* -------------------------------------------------
   4️⃣  Helper functions (used by triggers)
   ------------------------------------------------- */
CREATE OR REPLACE FUNCTION public.add_booking_revenue()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.revenue (
        booking_id,
        income,
        month,
        year
    ) VALUES (
        NEW.id,
        NEW.total_amount,
        EXTRACT(MONTH FROM NEW.created_at)::int,
        EXTRACT(YEAR FROM NEW.created_at)::int
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.add_expense_revenue()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.revenue (
        booking_id,
        expense_id,
        expense,
        month,
        year
    ) VALUES (
        NEW.booking_id,
        NEW.id,
        NEW.amount,
        NEW.month,
        NEW.year
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.set_expense_month_year()
RETURNS TRIGGER AS $$
BEGIN
    NEW.month := EXTRACT(MONTH FROM NEW.date);
    NEW.year  := EXTRACT(YEAR  FROM NEW.date);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.set_revenue_month_year()
RETURNS TRIGGER AS $$
BEGIN
    NEW.month := EXTRACT(MONTH FROM NEW.created_at);
    NEW.year  := EXTRACT(YEAR  FROM NEW.created_at);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.notify_low_stock()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.current_stock < NEW.min_stock THEN
        INSERT INTO public.notifications (
            type,
            title,
            message,
            priority,
            related_item
        ) VALUES (
            'inventory',
            'Low Stock Alert',
            format('Item "%s" is low on stock. Current: %s, Minimum: %s',
                   NEW.name, NEW.current_stock, NEW.min_stock),
            'high',
            NEW.id
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.set_booking_created_at()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.created_at IS NULL THEN
        NEW.created_at := now();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_booking_revenue()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'cancelled' THEN
        DELETE FROM public.revenue
        WHERE booking_id = NEW.id
          AND expense_id IS NULL;
    ELSE
        UPDATE public.revenue
        SET income = NEW.total_amount,
            month = EXTRACT(MONTH FROM NEW.created_at)::int,
            year = EXTRACT(YEAR FROM NEW.created_at)::int
        WHERE booking_id = NEW.id
          AND expense_id IS NULL;
        -- If no row exists (e.g., revenue was never created), insert it
        IF NOT FOUND THEN
            INSERT INTO public.revenue (booking_id, income, month, year)
            VALUES (NEW.id, NEW.total_amount,
                EXTRACT(MONTH FROM NEW.created_at)::int,
                EXTRACT(YEAR FROM NEW.created_at)::int);
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function that syncs revenue on booking UPDATE/DELETE
CREATE OR REPLACE FUNCTION public.sync_booking_revenue()
RETURNS TRIGGER AS $$
BEGIN
    ----------------------------------------------------------------
    -- 1️⃣  UPDATE case (status not cancelled)
    ----------------------------------------------------------------
    IF TG_OP = 'UPDATE' THEN
        IF NEW.status = 'cancelled' THEN
            -- Cancelled → remove the revenue entry (only the booking‑only row)
            DELETE FROM public.revenue
            WHERE booking_id = NEW.id
              AND expense_id IS NULL;
        ELSE
            -- Amount or date changed → upsert the revenue row
            UPDATE public.revenue
            SET income = NEW.total_amount,
                month  = EXTRACT(MONTH FROM NEW.created_at)::int,
                year   = EXTRACT(YEAR  FROM NEW.created_at)::int
            WHERE booking_id = NEW.id
              AND expense_id IS NULL;

            IF NOT FOUND THEN
                INSERT INTO public.revenue (booking_id, income, month, year)
                VALUES (NEW.id,
                        NEW.total_amount,
                        EXTRACT(MONTH FROM NEW.created_at)::int,
                        EXTRACT(YEAR  FROM NEW.created_at)::int);
            END IF;
        END IF;

    ----------------------------------------------------------------
    -- 2️⃣  DELETE case (booking removed)
    ----------------------------------------------------------------
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.revenue
        WHERE booking_id = OLD.id
          AND expense_id IS NULL;
    END IF;

    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql;

-- Function that syncs revenue on expense UPDATE/DELETE
CREATE OR REPLACE FUNCTION public.sync_expense_revenue()
RETURNS TRIGGER AS $$
BEGIN
    ----------------------------------------------------------------
    -- 1️⃣  UPDATE case
    ----------------------------------------------------------------
    IF TG_OP = 'UPDATE' THEN
        UPDATE public.revenue
        SET booking_id = NEW.booking_id,
            expense    = NEW.amount,
            month      = EXTRACT(MONTH FROM NEW.date)::int,
            year       = EXTRACT(YEAR  FROM NEW.date)::int
        WHERE expense_id = NEW.id;

        -- If the row does not exist (e.g., expense was added before the trigger existed)
        IF NOT FOUND THEN
            INSERT INTO public.revenue (booking_id, expense_id, expense, month, year)
            VALUES (NEW.booking_id,
                    NEW.id,
                    NEW.amount,
                    EXTRACT(MONTH FROM NEW.date)::int,
                    EXTRACT(YEAR  FROM NEW.date)::int);
        END IF;

    ----------------------------------------------------------------
    -- 2️⃣  DELETE case
    ----------------------------------------------------------------
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.revenue
        WHERE expense_id = OLD.id;
    END IF;

    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql;

-- Auto-create notifications for overdue tasks
CREATE OR REPLACE FUNCTION notify_overdue_tasks()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.due_date < CURRENT_DATE OR 
       (NEW.due_date = CURRENT_DATE AND NEW.due_time < CURRENT_TIME) THEN
        INSERT INTO public.notifications (
            type, title, message, priority, related_task
        ) VALUES (
            'housekeeping',
            'Overdue Task',
            format('Task "%s" in room %s is overdue', NEW.task_type, NEW.room_number),
            'high',
            NEW.id
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 1) New booking insert notification
CREATE OR REPLACE FUNCTION public.notify_booking_insert()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.notifications (
    type, title, message, priority, related_booking, created_at
  ) VALUES (
    'booking',
    'New Booking Confirmed',
    format(
      'Booking from %s to %s (amount: %s)',
      COALESCE(TO_CHAR(NEW.check_in, 'YYYY-MM-DD'),'N/A'),
      COALESCE(TO_CHAR(NEW.check_out,'YYYY-MM-DD'),'N/A'),
      COALESCE(NEW.total_amount::text,'0')
    ),
    'medium',
    NEW.id,
    now()
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notify_booking_insert
AFTER INSERT ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.notify_booking_insert();

-- 2) Booking update notifications (status changes, date changes)
CREATE OR REPLACE FUNCTION public.notify_booking_update()
RETURNS TRIGGER AS $$
BEGIN
  -- Status change notifications
  IF TG_OP = 'UPDATE' AND COALESCE(OLD.status,'') <> COALESCE(NEW.status,'') THEN
    IF NEW.status = 'cancelled' THEN
      INSERT INTO public.notifications (type, title, message, priority, related_booking, created_at)
      VALUES (
        'booking',
        'Booking Cancelled',
        format('Booking for %s → %s has been cancelled', COALESCE(TO_CHAR(NEW.check_in,'YYYY-MM-DD'),'N/A'), COALESCE(TO_CHAR(NEW.check_out,'YYYY-MM-DD'),'N/A')),
        'medium',
        NEW.id,
        now()
      );
    ELSIF NEW.status = 'confirmed' THEN
      INSERT INTO public.notifications (type, title, message, priority, related_booking, created_at)
      VALUES (
        'booking',
        'Booking Confirmed',
        format('Booking confirmed for %s → %s', COALESCE(TO_CHAR(NEW.check_in,'YYYY-MM-DD'),'N/A'), COALESCE(TO_CHAR(NEW.check_out,'YYYY-MM-DD'),'N/A')),
        'medium',
        NEW.id,
        now()
      );
    END IF;
  END IF;

  -- Date change notification (check_in/check_out changed)
  IF TG_OP = 'UPDATE' AND (COALESCE(OLD.check_in::text,'') <> COALESCE(NEW.check_in::text,'') OR COALESCE(OLD.check_out::text,'') <> COALESCE(NEW.check_out::text,'')) THEN
    INSERT INTO public.notifications (type, title, message, priority, related_booking, created_at)
    VALUES (
      'booking',
      'Booking Dates Updated',
      format('Booking dates updated: %s → %s', COALESCE(TO_CHAR(NEW.check_in,'YYYY-MM-DD'),'N/A'), COALESCE(TO_CHAR(NEW.check_out,'YYYY-MM-DD'),'N/A')),
      'medium',
      NEW.id,
      now()
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notify_booking_update
AFTER UPDATE ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.notify_booking_update();

-- 3) Scheduled check-in reminders (create notifications for bookings that check in tomorrow)
-- This function is intended to be called once per day (e.g., via pg_cron or external scheduler).
CREATE OR REPLACE FUNCTION public.create_checkin_reminders()
RETURNS void AS $$
BEGIN
  INSERT INTO public.notifications (type, title, message, priority, related_booking, created_at)
  SELECT
    'checkin'::text,
    'Guest Check-in Tomorrow',
    format('Guest scheduled to check in on %s', TO_CHAR(b.check_in,'YYYY-MM-DD')),
    'medium'::notification_priority,
    b.id,
    now()
  FROM public.bookings b
  WHERE b.status = 'confirmed'
    AND b.check_in = (CURRENT_DATE + INTERVAL '1 day')::date
    -- avoid creating duplicates for the same booking within the same day
    AND NOT EXISTS (
      SELECT 1 FROM public.notifications n
      WHERE n.related_booking = b.id
        AND n.type = 'checkin'
        AND DATE(n.created_at) = CURRENT_DATE
    );
END;
$$ LANGUAGE plpgsql;


/* -------------------------------------------------
   5️⃣  Triggers
   ------------------------------------------------- */
CREATE TRIGGER trg_add_booking_revenue
AFTER INSERT ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.add_booking_revenue();

CREATE TRIGGER trg_add_expense_revenue
AFTER INSERT ON public.expenses
FOR EACH ROW
EXECUTE FUNCTION public.add_expense_revenue();

CREATE TRIGGER trg_set_expense_month_year
BEFORE INSERT ON public.expenses
FOR EACH ROW
EXECUTE FUNCTION public.set_expense_month_year();

CREATE TRIGGER trg_set_revenue_month_year
BEFORE INSERT ON public.revenue
FOR EACH ROW
EXECUTE FUNCTION public.set_revenue_month_year();

CREATE TRIGGER trg_notify_low_stock
AFTER INSERT OR UPDATE ON public.inventory_items
FOR EACH ROW
EXECUTE FUNCTION public.notify_low_stock();

CREATE TRIGGER trg_set_booking_created_at
BEFORE INSERT ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.set_booking_created_at();

CREATE TRIGGER trg_sync_booking_revenue
AFTER UPDATE OR DELETE ON public.bookings
FOR EACH ROW
EXECUTE FUNCTION public.sync_booking_revenue();

CREATE TRIGGER trg_sync_expense_revenue
AFTER UPDATE OR DELETE ON public.expenses
FOR EACH ROW
EXECUTE FUNCTION public.sync_expense_revenue();